<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.26.0">
    <meta name="project" content="bonfire v0.1.0-cooperation-beta.94">

    <title>AbsintheClient â€” bonfire v0.1.0-cooperation-beta.94</title>
    <link rel="stylesheet" href="dist/elixir-b5076885a795c65e636c.css" />

    <script src="dist/sidebar_items-54533f5835.js"></script>

      <script src="docs_config.js"></script>

    <script async src="dist/app-a404e1e870b77c874f9e.js"></script>


  </head>
  <body data-type="modules">
    <script>

      try {
        if (localStorage.getItem('night-mode') === 'true') {
          document.body.classList.add('night-mode');
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <span class="icon-search" aria-hidden="true" title="Submit search"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <span class="icon-cross" aria-hidden="true" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="readme.html" class="sidebar-projectName" translate="no">
bonfire
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v0.1.0-cooperation-beta.94
      </strong>
    </div>

      <a href="readme.html">
        <img src="assets/logo.png" alt="bonfire" class="sidebar-projectImage">
      </a>

  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list-link" href="#full-list">Pages</a></li>

      <li><a id="modules-list-link" href="#full-list">Modules</a></li>


      <li><a id="tasks-list-link" href="#full-list"><span translate="no">Mix</span> Tasks</a></li>

  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
  <span translate="no">AbsintheClient</span> <small>behaviour</small>
  <small class="app-vsn" translate="no">(bonfire v0.1.0-cooperation-beta.94)</small>


</h1>


  <section id="moduledoc">
<p>Supports use of GraphQL documents from with app containing the Absinthe schema</p><h2 id="module-example" class="section-heading">
  <a href="#module-example" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Example
</h2>
<p>First, <code class="inline">use AbsintheClient</code>, passing your <code class="inline">schema</code> and
notifying Absinthe to operate in <code class="inline">internal</code> mode:</p><pre><code class="makeup elixir"><span class="kd">defmodule</span><span class="w"> </span><span class="nc">MyAppWeb.UserController</span><span class="w"> </span><span class="k" data-group-id="1751733057-1">do</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">MyAppWeb</span><span class="p">,</span><span class="w"> </span><span class="ss">:controller</span><span class="w">
  </span><span class="kn">use</span><span class="w"> </span><span class="nc">AbsintheClient</span><span class="p">,</span><span class="w"> </span><span class="ss">schema</span><span class="p">:</span><span class="w"> </span><span class="nc">MyAppWeb.Schema</span><span class="p">,</span><span class="w"> </span><span class="ss">action</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1751733057-2">[</span><span class="ss">mode</span><span class="p">:</span><span class="w"> </span><span class="ss">:internal</span><span class="p" data-group-id="1751733057-2">]</span><span class="w">

  </span><span class="c1"># ... actions</span><span class="w">

</span><span class="k" data-group-id="1751733057-1">end</span></code></pre><p>For each action you want Absinthe to process, provide a GraphQL document using
the <code class="inline">@graphql</code> module attribute (before the action):</p><pre><code class="makeup elixir"><span class="na">@graphql</span><span class="w"> </span><span class="s">&quot;&quot;&quot;
  query ($filter: UserFilter) {
    users(filter: $filter, limit: 10)
  }
&quot;&quot;&quot;</span><span class="w">
</span><span class="kd">def</span><span class="w"> </span><span class="nf">index</span><span class="p" data-group-id="2446326691-1">(</span><span class="n">conn_or_socket</span><span class="p">,</span><span class="w"> </span><span class="p" data-group-id="2446326691-2">%{</span><span class="ss">data</span><span class="p">:</span><span class="w"> </span><span class="n">data</span><span class="p" data-group-id="2446326691-2">}</span><span class="p" data-group-id="2446326691-1">)</span><span class="w"> </span><span class="k" data-group-id="2446326691-3">do</span><span class="w">
  </span><span class="n">render</span><span class="w"> </span><span class="n">conn_or_socket</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;index.html&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="w">
</span><span class="k" data-group-id="2446326691-3">end</span></code></pre><p>The params for the action will be intercepted by the
<code class="inline">AbsintheClient.Action</code> plug, and used as variables for
the GraphQL document you've specified.</p><p>For instance, given a definition for a <code class="inline">:user_filter</code> input object
type like this:</p><pre><code class="makeup elixir"><span class="n">input_object</span><span class="w"> </span><span class="ss">:user_filter</span><span class="w"> </span><span class="k" data-group-id="1218542998-1">do</span><span class="w">
  </span><span class="n">field</span><span class="w"> </span><span class="ss">:name_matches</span><span class="p">,</span><span class="w"> </span><span class="ss">:string</span><span class="w">
  </span><span class="n">field</span><span class="w"> </span><span class="ss">:age_above</span><span class="p">,</span><span class="w"> </span><span class="ss">:integer</span><span class="w">
  </span><span class="n">field</span><span class="w"> </span><span class="ss">:age_below</span><span class="p">,</span><span class="w"> </span><span class="ss">:integer</span><span class="w">
</span><span class="k" data-group-id="1218542998-1">end</span></code></pre><p>And a query that looks like this (assuming you have the normal
<a href="https://hexdocs.pm/plug/1.12.1/Plug.Parsers.html"><code class="inline">Plug.Parsers</code></a> configuration for param parsing):</p><pre><code class="makeup elixir"><span class="sc">?f</span><span class="n">ilter</span><span class="p" data-group-id="1437819360-1">[</span><span class="n">name_matches</span><span class="p" data-group-id="1437819360-1">]</span><span class="o">=</span><span class="n">joe</span><span class="o">&amp;</span><span class="n">filter</span><span class="p" data-group-id="1437819360-2">[</span><span class="n">age_above</span><span class="p" data-group-id="1437819360-2">]</span><span class="o">=</span><span class="mi">42</span></code></pre><p>Then Absinthe will receive variable definitions of:</p><pre><code class="makeup elixir"><span class="p" data-group-id="1243738163-1">%{</span><span class="s">&quot;filter&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p" data-group-id="1243738163-2">%{</span><span class="s">&quot;name_matches&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="s">&quot;joe&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;age_above&quot;</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="mi">42</span><span class="p" data-group-id="1243738163-2">}</span><span class="p" data-group-id="1243738163-1">}</span></code></pre><p>(For how the string <code class="inline">&quot;42&quot;</code> was converted into <code class="inline">42</code>, see <code class="inline">cast_param/3</code>).</p><p>The params on the <code class="inline">conn_or_socket</code> will then be replaced by the result of the
execution by Absinthe. The action function can then match against
that result to respond correctly to the user:</p><p>It's up to you to handle the three possible results:</p><ul><li>When there's <code class="inline">:data</code> but no <code class="inline">:errors</code>, everything went perfectly.</li><li>When there's <code class="inline">:errors</code> but no <code class="inline">:data</code>, a validation error occurred and the document could not be
executed.</li><li>When there's <code class="inline">:data</code> and <code class="inline">:errors</code>, partial data is available but some fields reported errors
during execution.</li></ul><p>Notice the keys are atoms, not strings as in normal Phoenix action invocations.</p><h2 id="module-differences-with-the-graphql-specification" class="section-heading">
  <a href="#module-differences-with-the-graphql-specification" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Differences with the GraphQL Specification
</h2>
<p>There are some important differences between GraphQL documents as
processed in an HTTP API and the GraphQL documents that this module
supports.</p><p>In an effort to make use of GraphQL ergonomic in Elixir,
Absinthe supports some slight structural modifications to
the GraphQL documents provided using the <code class="inline">@graphql</code> module attribute
in controller modules.</p><p>In a way, you can think of these changes as a specialized GraphQL
dialect. The following are the differences you need to keep in mind.</p><h3 id="module-objects-can-be-leaf-nodes" class="section-heading">
  <a href="#module-objects-can-be-leaf-nodes" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Objects can be leaf nodes
</h3>
<p>Let's look at the <code class="inline">users</code> example mentioned before:</p><pre><code class="makeup elixir"><span class="na">@graphql</span><span class="w"> </span><span class="s">&quot;&quot;&quot;
  query ($filter: UserFilter) {
    users(filter: $filter, limit: 10)
  }
&quot;&quot;&quot;</span></code></pre><p>You'll notice that in the above example, <code class="inline">users</code> doesn't have an
accompanying <em>selection set</em> (that is, a set of child fields bounded
by <code class="inline">{ ... }</code>). The GraphQL specification dictates that only scalar
values can be &quot;leaf nodes&quot; in a GraphQL document... but to support
unmodified struct values being returned (for example, Ecto schemas),
if no selection set is provided for an object value (or list
thereof), the entire value is returned.</p><p>The template can then use <code class="inline">users</code> as needed:</p><pre><code class="makeup elixir"><span class="o">&lt;</span><span class="n">ul</span><span class="o">&gt;</span><span class="w">
  </span><span class="o">&lt;</span><span class="p">%</span><span class="o">=</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">user</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="na">@users</span><span class="w"> </span><span class="k" data-group-id="5080453232-1">do</span><span class="w"> </span><span class="p">%</span><span class="o">&gt;</span><span class="w">
    </span><span class="o">&lt;</span><span class="n">li</span><span class="o">&gt;</span><span class="o">&lt;</span><span class="p">%</span><span class="o">=</span><span class="w"> </span><span class="n">link</span><span class="w"> </span><span class="n">user</span><span class="o">.</span><span class="n">full_name</span><span class="p">,</span><span class="w"> </span><span class="ss">to</span><span class="p">:</span><span class="w"> </span><span class="n">user_path</span><span class="p" data-group-id="5080453232-2">(</span><span class="na">@conn_or_socket</span><span class="p">,</span><span class="w"> </span><span class="ss">:show</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p" data-group-id="5080453232-2">)</span><span class="w"> </span><span class="p">%</span><span class="o">&gt;</span><span class="o">&lt;</span><span class="o">/</span><span class="n">li</span><span class="o">&gt;</span><span class="w">
  </span><span class="o">&lt;</span><span class="p">%</span><span class="w"> </span><span class="k" data-group-id="5080453232-1">end</span><span class="w"> </span><span class="p">%</span><span class="o">&gt;</span><span class="w">
</span><span class="o">&lt;</span><span class="o">/</span><span class="n">ul</span><span class="o">&gt;</span></code></pre><p>This is useful for <a href="https://hexdocs.pm/phoenix_html/3.1.0/Phoenix.HTML.html"><code class="inline">Phoenix.HTML</code></a> helper functions that expect
structs with specific fields (especially <code class="inline">form_for</code>).</p><p>One way to think of this change is that, for objects, no selection
set is equivalent to a &quot;splat&quot; operator (except, of course, even
fields not defined in your GraphQL schema are returned as part of
the value).</p><p>But, never fear, nothing is stopping you from ignoring this behavior
and providing a selection set if you want a traditionally narrow set
of fields:</p><pre><code class="makeup elixir"><span class="na">@graphql</span><span class="w"> </span><span class="s">&quot;&quot;&quot;
  query ($filter: UserFilter) {
    users(filter: $filter, limit: 10) {
      id
      full_name
    }
  }
&quot;&quot;&quot;</span></code></pre><h3 id="module-scalar-values-aren-t-serialized" class="section-heading">
  <a href="#module-scalar-values-aren-t-serialized" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Scalar values aren't serialized
</h3>
<p>To remove the need for reparsing values, scalar values aren't serialized;
Phoenix actions receive the original, unserialized values of GraphQL fields.</p><p>This is especially useful for custom scalar types. Using a couple of the
additional types packaged in <a href="https://hexdocs.pm/absinthe/1.6.6/Absinthe.Type.Custom.html"><code class="inline">Absinthe.Type.Custom</code></a>, for example:</p><ul><li><code class="inline">:decimal</code> values are returned as <code class="inline">%Decimal{}</code> structs, not strings.</li><li><code class="inline">:datetime</code> values are returned as <code class="inline">%DateTime{}</code> structs, not strings.</li></ul><p>In short, GraphQL used in controllers is a query language to retrieve the values requested---there's no need to serialize the
values to send them across HTTP.</p><h3 id="module-fields-use-snake_case" class="section-heading">
  <a href="#module-fields-use-snake_case" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Fields use snake_case
</h3>
<p>Unlike in the GraphQL notation scheme we prefer for GraphQL APIs (that is,
<code class="inline">camelCase</code> fields, which better match up with the expectations of JavaScript
clients), fields used in documents provided as <code class="inline">@graphql</code> should use
<code class="inline">snake_case</code> naming, as Elixir conventions use that notation style for atoms,
etc.</p><h3 id="module-atom-keys" class="section-heading">
  <a href="#module-atom-keys" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Atom keys
</h3>
<p>Because you are writing the GraphQL document in your controller and Absinthe
is validating the document against your schema, atom keys are returned for
field names.</p>
  </section>


  <section id="summary" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#summary">
        <span class="icon-link" aria-hidden="true"></span>
        <span class="sr-only">Link to this section</span>
      </a>
      Summary
    </h1>

  <div class="summary-callbacks summary">
    <h2>
      <a href="#callbacks">Callbacks</a>
    </h2>

      <div class="summary-row">
        <div class="summary-signature">
          <a href="#c:absinthe_pipeline/2" translate="no">absinthe_pipeline(schema, t)</a>

        </div>

          <div class="summary-synopsis"><p>Customize the Absinthe processing pipeline.</p></div>

      </div>

      <div class="summary-row">
        <div class="summary-signature">
          <a href="#c:cast_param/3" translate="no">cast_param(
  value,
  target_type,
  schema
)</a>

        </div>

          <div class="summary-synopsis"><p>Cast string param values to values Absinthe expects for variable input.</p></div>

      </div>

  </div>

  <div class="summary-functions summary">
    <h2>
      <a href="#functions">Functions</a>
    </h2>

      <div class="summary-row">
        <div class="summary-signature">
          <a href="#default_pipeline/2" translate="no">default_pipeline(schema, options)</a>

        </div>

      </div>

      <div class="summary-row">
        <div class="summary-signature">
          <a href="#variables/1" translate="no">variables(conn_or_socket)</a>

        </div>

      </div>

  </div>

  </section>


  <section id="callbacks" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#callbacks">
        <span class="icon-link" aria-hidden="true"></span>
        <span class="sr-only">Link to this section</span>
      </a>
Callbacks
    </h1>
    <div class="callbacks-list">
<section class="detail" id="c:absinthe_pipeline/2">

  <div class="detail-header">
    <a href="#c:absinthe_pipeline/2" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature" translate="no">absinthe_pipeline(schema, t)</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre translate="no">absinthe_pipeline(schema :: <a href="https://hexdocs.pm/absinthe/1.6.6/Absinthe.Schema.html#t:t/0">Absinthe.Schema.t</a>(), <a href="https://hexdocs.pm/elixir/Keyword.html#t:t/0">Keyword.t</a>()) ::
  <a href="https://hexdocs.pm/absinthe/1.6.6/Absinthe.Pipeline.html#t:t/0">Absinthe.Pipeline.t</a>()</pre>

      </div>

<p>Customize the Absinthe processing pipeline.</p><p>Only implement this function if you need to change the pipeline used
to process documents.</p>
  </section>
</section>
<section class="detail" id="c:cast_param/3">

  <div class="detail-header">
    <a href="#c:cast_param/3" class="detail-link" title="Link to this callback">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this callback</span>
    </a>
    <h1 class="signature" translate="no">cast_param(
  value,
  target_type,
  schema
)</h1>


  </div>

  <section class="docstring">

      <h2>Specs</h2>
      <div class="specs">

          <pre translate="no">cast_param(
  value :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>(),
  target_type :: Absinthe.Type.t(),
  schema :: <a href="https://hexdocs.pm/absinthe/1.6.6/Absinthe.Schema.html#t:t/0">Absinthe.Schema.t</a>()
) :: <a href="https://hexdocs.pm/elixir/typespecs.html#basic-types">any</a>()</pre>

      </div>

<p>Cast string param values to values Absinthe expects for variable input.</p><p>Some scalar types, like <code class="inline">:integer</code> (GraphQL <code class="inline">Int</code>) require that raw,
incoming value be a non-string type. This isn't a problem in
GraphQL-over-HTTP because the variable values are provided as a JSON
payload (which supports, i.e., integer values).</p><p>To support converting incoming param values to the format that
certain scalars expect, we support a <code class="inline">cast_param/3</code> callback
function that takes a raw value, target type (e.g., the scalar
type), and the schema, and returns the transformed
value. <code class="inline">cast_param/3</code> is overridable and the implementation already
supports <code class="inline">:integer</code> and <code class="inline">:float</code> types.</p><p>If you override <code class="inline">cast_param/3</code>, make sure you super or handle lists,
non-nulls, and input object values yourself; they're also processed
using the function.</p><p>Important: In the event that a value is <em>invalid</em>, just return it
unchanged so that Absinthe's usual validation logic can report it as
invalid.</p>
  </section>
</section>

    </div>
  </section>

  <section id="functions" class="details-list">
    <h1 class="section-heading">
      <a class="hover-link" href="#functions">
        <span class="icon-link" aria-hidden="true"></span>
        <span class="sr-only">Link to this section</span>
      </a>
Functions
    </h1>
    <div class="functions-list">
<section class="detail" id="default_pipeline/2">

  <div class="detail-header">
    <a href="#default_pipeline/2" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">default_pipeline(schema, options)</h1>


  </div>

  <section class="docstring">


  </section>
</section>
<section class="detail" id="variables/1">

  <div class="detail-header">
    <a href="#variables/1" class="detail-link" title="Link to this function">
      <span class="icon-link" aria-hidden="true"></span>
      <span class="sr-only">Link to this function</span>
    </a>
    <h1 class="signature" translate="no">variables(conn_or_socket)</h1>


  </div>

  <section class="docstring">


  </section>
</section>

    </div>
  </section>

      <footer class="footer">

        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.26.0) for the
            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>.
          </span>
          <span class="line">
            Designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire" translate="no">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>

            <a href="api-reference.html" title="API reference" class="line footer-button">API Reference</a>

          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
          <button class="line footer-button display-quick-switch">
            Go to a HexDocs package
          </button>
          <button class="line footer-button display-settings">
            Settings
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
